{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Fliq","text":"<p>Fluent-syntaxed Lazily-evaluated Integrated Query.</p> <p> </p> <p> </p> <p>Fliq is a lightweight Python library for high-performance lazy processing of iterables. Inspired by Django's ORM and LINQ, it provides a fluent syntax for lazily-evaluated operations on iterables,  and it is tested to have on-par performance with the standard library. Also, for all you type-a-holics, Fliq is fully equipped with generic type hints, so it supports mypy in strict mode.</p> <ul> <li>Documentation: https://oribarilan.github.io/fliq</li> <li>Source Code: https://github.com/oribarilan/fliq</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install fliq\n</code></pre> <ul> <li>Fliq does not have any dependencies.</li> <li>Fliq supports Python 3.9 and above.</li> </ul>"},{"location":"#fliq-is","title":"Fliq is","text":"<ul> <li>\ud83d\udca1 Intuitive to use. Built for readability and usability. Fully typed.</li> <li>\ud83e\udeb6 Lightweight wrapper for the standard library. No dependencies or bloat.</li> <li>\u26a1\ufe0f Efficient as the standard library. Abstraction overhead is kept to a minimum. </li> <li>\u23f3 Lazy evaluated, executed only when needed and only as needed.</li> <li>\ud83d\udd17 Versatile by supporting any iterable type, including infinite iterables.</li> <li>\ud83e\udde9 Compatible with APIs consuming iterables. No integration or setup required.</li> </ul>"},{"location":"#motivation","title":"Motivation","text":"<p>What is the output of the following code? <pre><code>next(map(lambda x: x * 2, filter(lambda x: x % 2 == 0, [1, 2, 3, 4, 5])), -1)\n</code></pre></p> <p>And what about this? <pre><code>from fliq import q\n(q([1, 2, 3, 4, 5])\n.where(lambda x: x % 2 == 0)\n.select(lambda x: x * 2)\n.first(default=-1))\n</code></pre></p> <p>And this is just a simple example.</p> <p>Python's standard library provides a rich set of functions for processing iterables. However, it is not always easy to read and use. </p> <p>This is especially true when chaining multiple operations together. This is where Fliq comes in. Fliq provides a fluent, easy to read syntax for processing iterables, while keeping performance on-par with the standard library.</p>"},{"location":"#performance","title":"Performance","text":"<p>Fliq is geared for performance:</p> <ul> <li>\ud83d\udecc It is lazily evaluated without requiring any intentional effort from the user.</li> <li>\u26a1\ufe0f It is also tested to have on-par performance with the standard library.</li> </ul> <p>There are two mechanisms for checking Fliq's performance: </p> <ul> <li>\ud83e\uddea Performance tests are ran on every commit, and they compare Fliq's performance to the standard library.</li> <li>\ud83d\udcca Benchmarking is done against the standard library.</li> </ul> <p>Here is a glimpse of the benchmarking results: </p> <p>You can read more about Fliq's performance here.</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#tonnys-socks","title":"Tonny's Socks \ud83e\udde6","text":"<p>Tonny is terrible at doing laundry. He has a drawer full of socks, but none of them match.  He needs to find a pair of matching socks before he can go to work. Also, it is Christmas, so preferably something in the holiday spirit.</p> <pre><code>from fliq import q\nfrom dataclasses import dataclass\n@dataclass\nclass Sock:\ncolor: str\nfoot: str\nsock_drawer = [\nSock('red', 'left'), Sock('green', 'left'), Sock('burgers', 'left'), Sock('aliens', 'right'),\nSock('avocados', 'left'), Sock('avocados', 'right'), Sock('red', 'right'), Sock('burgers', 'left')\n]\n# split socks into singles and pairs\nsingles, pairs = q(sock_drawer).group_by('color').partition(by=lambda g: len(g) == 2)\n# put singles back in the drawer\nsock_drawer = singles.flatten().to_list()\n# find a pair of red socks or default to boring black\npair = pairs.first(lambda p: p[0].color == 'red', default=(Sock('boring black', 'left'), Sock('boring black', 'right')))\nprint(f\"Tonny's socks for today are {pair[0].color}! \ud83c\udf84\ud83c\udf85\ud83c\udffc\ud83c\udf81\ud83e\udde6\ud83e\udde6\ud83c\udf81\ud83c\udf85\ud83c\udffc\ud83c\udf84\")\n</code></pre>"},{"location":"examples/#language-contest","title":"Language Contest \ud83d\udc68\u200d\ud83d\udcbb\ud83c\udfc6","text":"<p>Let's find out which programming language is the most popular.</p>"},{"location":"examples/#the-easy-way","title":"The Easy Way","text":"<pre><code>from fliq import q\nlanguages = ['Python', 'JavaScript', 'C#', 'Java', 'C++', 'C']\npopular_languages = q(languages).order(by=lambda l: len(l), ascending=False).to_list()\nprint(f\"Here are the most popular programming languages: {popular_languages} \ud83d\ude05\")\n# ['JavaScript', 'Python', 'C++', 'Java', 'C#', 'C']\n</code></pre>"},{"location":"examples/#the-hard-way","title":"The Hard Way","text":"<p>We'll use the GitHub API to get the top 100 repos by stars, and then count the appearances of each language.</p> <pre><code>import requests\nfrom collections import Counter\nfrom fliq import q\n# get the top 100 repos by stars\nrepos = requests.get('https://api.github.com/search/repositories?q=stars:&gt;1&amp;sort=stars&amp;per_page=100').json()['items']\n# get the language for each repo\nlanguages = q(repos).select(lambda r: r['language']).where(lambda l: l is not None)\n# peek to see a language, without removing it from the query\npeeked_language = languages.peek()\nprint(f\"Here's a peek at the languages: {peeked_language}\")\n# count popularity of each language using Counter (that accepts an iterable)\npopular_languages = Counter(languages).most_common(n=6)\nprint(f\"Here are the most popular programming languages: {popular_languages} \ud83d\udcaa\ud83e\uddea\ud83d\udd0d\")\n# [('JavaScript', 16), ('TypeScript', 15), ('Python', 13), (None, 13), ('C', 5), ('Java', 5) ...]\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<pre><code>pip install fliq\n</code></pre>"},{"location":"getting_started/#usage","title":"Usage","text":"<p>Fliq's main class is called <code>Query</code>. We suggest you import it as <code>q</code>, because you will use it all the time \ud83d\ude09 <pre><code>from fliq import q\nq([1, 2, 3, 4, 5]).take(1)\n</code></pre> You can also import it as <code>Query</code> if you prefer, we don't judge: <pre><code>from fliq import Query\nQuery([1, 2, 3, 4, 5]).take(1)\n</code></pre></p>"},{"location":"getting_started/#what-is-a-query-and-why-should-you-use-it","title":"What is a Query, and why should you use it?","text":"<p>A <code>Query</code> can be viewed as a wrapper for any python iterable. It guarantees that the iterable will be evaluated lazily, and provides a rich set of methods for transforming and querying the data.</p>"},{"location":"getting_started/#speed-up-your-code","title":"\u26a1 **** Speed up your code","text":"<p>Data will only be materialized when you ask for it. This means that you can create a <code>Query</code> from a very large iterable, and only materialize a small portion of it. This is extremely efficient.</p>"},{"location":"getting_started/#speed-up-your-development","title":"\ud83d\udd25\ud83d\udc68\u200d\ud83d\udcbb Speed up your development","text":"<ol> <li>\ud83d\udcd6 Readability. The methods provided by <code>Query</code> are designed to be chained together, so you    can create complex data pipelines with much less cognitive load.</li> <li>\ud83d\udc1e\ud83d\udd0d Inspectability. <code>Query</code> provides functionality that speeds development.     For example, despite being lazy and exhaustible, you can always    peek() into a query.     Moreover, queries have a meaningful string representation.    So you can view the contents of a query, without consuming it. This is extremely useful for debugging.</li> </ol> <p>So the question is... Why not?</p>"},{"location":"getting_started/#i-am-excited-whats-next","title":"I am excited! What's next? \ud83e\udd29","text":"<ol> <li>We know it is hard to believe, but it is true! Breath in, breath out, and continue to (2).</li> <li>Take a look at our easy-to-follow examples: Examples</li> <li>Wonder around our API Reference</li> <li>Understand what are mappers and materializers at API Intro</li> <li>Check out our rich functionality at API Index</li> <li>Make sure you don't miss our special functionality, linked from the top of the API Index.</li> </ol>"},{"location":"misc/performance/","title":"Performance","text":"<p>Fliq is geared for performance:</p> <ul> <li>\ud83d\udecc It is lazily evaluated without requiring any intentional effort from the user.</li> <li>\u26a1\ufe0f It is also tested to have on-par performance with the standard library.</li> </ul>"},{"location":"misc/performance/#memory","title":"Memory","text":"<p>Fliq is lazy. It does not materialize the iterable, unless the operation requires it (e.g., reverse). This allows Fliq to make minimal use of memory.</p> <p>Abstracting the (lazy) evaluation, reduces cognitive load from the user,  thus implicitly opting in for a more efficient computation, which in turn improves efficiency compared to eager list processing code.</p>"},{"location":"misc/performance/#performance_1","title":"Performance","text":"<p>Fliq is designed to be a lightweight wrapper for the standard library. It keeps abstraction overhead to a minimum,  and it is tested to have on-par performance with the standard library.</p> <p>There are two mechanisms for checking Fliq's performance: Performance tests and benchmarking.</p>"},{"location":"misc/performance/#performance-tests","title":"Performance Tests","text":"<p>These tests are ran on every commit, and they compare Fliq's performance to the standard library. They allow performance difference to be <code>1%</code> or smaller, and they are ran on every Python version, 3.9 and above.</p> <p>You can find the performance tests in  Performance tests.</p>"},{"location":"misc/performance/#benchmarking","title":"Benchmarking","text":"<p>Fliq is being benchmarked against the standard library. The list of  benchmarked scenarios expands over time. </p> <p>Currently, there are 2 scenarios tested with varying dataset sizes (100, 10K, 1M).</p> <ul> <li>Scenario 1: zipping two iterables of Person objects,  and taking the first 5 (by age asc) that are of different gender. <pre><code>from fliq import q\nfrom fliq.tests.fliq_test_utils import gen_people\ndataset = gen_people(100)\nshuffled = q(dataset).shuffle()\nq(dataset).zip(shuffled).where(lambda ps: ps[0].gender != ps[1].gender).order(by=lambda ps: ps[0].age+ps[1].age).take(5).to_list()\n</code></pre></li> <li>Scenario 2: filtering prepending and appending a list of Person objects  <pre><code>from fliq import q\nfrom fliq.tests.fliq_test_utils import gen_people\ndataset = gen_people(100)\nfirst = gen_people(200)\nlast = gen_people(200)\nq(dataset).where(lambda p: 0 &lt;= p.age &lt; 100).prepend_many(first).append_many(last).select(lambda p: p.name).to_list()\n</code></pre></li> </ul> <p>In both scenarios, Fliq is on-par with the standard library:</p> <p> </p> <p>You can find the full benchmarking code at Benchmark.</p>"},{"location":"reference/api_intro/","title":"API Introduction","text":"<p>Fliq provides rich functionality to perform processing on datasets (aka iterables). This reference section provides concepts and a detailed description of the API.</p> <p>Note</p> <p>API docs contain type aliases to improve readability:</p> <ul> <li>Predicate. <code>Predicate = Callable[[T], bool]</code></li> <li>Selector. <code>Selector = Callable[[T], U]</code></li> <li>NumericSelector = <code>Selector[T, Union[int, float]]</code></li> <li>IndexSelector = <code>Selector[T, int]</code></li> </ul>"},{"location":"reference/api_intro/#query","title":"Query","text":"<p>Query is the main object in Fliq. It is an abstracted lazy iterable,  which can be used to perform processing on datasets.</p> <p>Query should be perceived as a generator-like collection.</p> <ul> <li>It provides built-in iterable functionality (such as <code>for</code>, <code>in</code> etc.).</li> <li>It can be exhausted (used only once).</li> </ul> <pre><code>from fliq import q\nq([1, 2, 3, 4]).where(lambda x: x % 2 == 0).select(lambda x: x * 2).to_list() \n# [4, 8]  \n</code></pre> <p>The main functionality of Query can be divided into two categories:  Mappers methods and Materializer methods.</p>"},{"location":"reference/api_intro/#mapper-methods","title":"Mapper Methods","text":"<p>Mapper methods (aka mappers) are used to transform the data in the Query. They are lazy, and follow fluent syntax. They can be chained together to create complex transformations that are lazy,  so they are only executed on demand. Mappers are implemented using the standard python library,  so they are highly efficient and performant.</p> <pre><code>from fliq import q\nq([0, 1, 2]).where(lambda x: x % 2 == 0).select(lambda x: x + 1) \n# Query object similar to [1, 3]\n</code></pre> <p>For the full list of mappers, please refer to the Mapper Methods section.</p>"},{"location":"reference/api_intro/#materializer-methods","title":"Materializer Methods","text":"<p>Materializer methods (aka materializers) are used to perform some action, and return a concrete result. To do that, they materialize the data in the Query  (i.e., execute delayed computation, chained thus far).</p> <p>A Materializer that aggregates the iterable to return a single value is called a Reducer. Most materializers are in-fact reducers.</p> <pre><code>from fliq import q\nq([0, 1, 2]).max() \n# 2\n</code></pre> <p>There are other materializers, which do not aggregate the iterable to a single value. For example, <code>to_list</code> returns a list of all the items in the iterable.</p> <pre><code>from fliq import q\nq([0, 1, 2]).where(lambda x: x % 2 == 0).to_list() \n# [0, 2]\n</code></pre> <p>For the full list of mappers, please refer to the Materializer Methods section.</p>"},{"location":"reference/api_intro/#special-functionality","title":"Special Functionality","text":"<p>You can also find special functionality in the Query API, such as snapshots (<code>snap()</code>). See the relevant pages under the Reference section for more information.</p>"},{"location":"reference/api_roadmap/","title":"API Roadmap","text":""},{"location":"reference/api_roadmap/#v1-foundational-rich-synchronous-functionality","title":"\ud83d\udcaa v1 - Foundational: Rich synchronous functionality","text":"<p>v1 is all about creating a strong foundation for the library:</p> <ul> <li>\ud83d\udee0\ufe0f Rich functionality</li> <li>\u26a1\ufe0f High performance</li> <li>\ud83d\udcaf Test coverage</li> <li>\ud83d\udcaf Documentation coverage</li> </ul>"},{"location":"reference/api_roadmap/#v2-async-over-sync-async-functionality-over-sync-iterables","title":"\ud83d\udd00 v2 - Async over Sync: Async functionality over sync iterables","text":"<p>Although v1 is still going strong, we are already planning for the future. We plan to add async functionality to the library to boost performance even further, while keeping the API simple and clean.</p>"},{"location":"reference/api_roadmap/#v3-async-over-async-async-functionality-over-async-iterables","title":"\ud83d\ude80 v3 - Async over Async: Async functionality over async iterables","text":"<p>Our longer term goal is to complete the entire async functionality,  by adding support for async iterables.</p>"},{"location":"reference/release_notes/","title":"Release Notes (What's New) \ud83e\udd29","text":""},{"location":"reference/release_notes/#v1120","title":"v1.12.0","text":"<ul> <li>\ud83c\udf1f Slide - new slide method for creating tuples that \"slide\" over a query, in a windowed fashion (a sliding window).</li> <li>\ud83c\udf1f Most Common - new most_common method for finding the most common <code>n</code> items in a query.</li> <li>\ud83c\udf1f Pairwise - new pairwise method for creating tuples that \"slide\" over a query, in a pairwise fashion (a sliding window of size 2, without overlap).</li> <li>\u2b06\ufe0f Update to <code>first</code> and <code>single</code> - added <code>default</code> parameter to the first and single methods which allows specifying a default value. If no default is specified, an exception is raised. This replaces the need for the additional <code>first_or_default</code> and <code>single_or_default</code> methods, which were removed. Also, some optimization to both methods (to avoid unnecessary try-except).</li> </ul>"},{"location":"reference/release_notes/#v1110","title":"v1.11.0","text":"<ul> <li>\u2b06\ufe0f Update to peek - added fillvalue to the peek method</li> <li>\ud83c\udf1f Query representation - to ease debugging, queries now have a <code>repr</code> method,  which returns a string representation of the query, including peeking into the query without consuming it.</li> <li>\u26a1\ufe0f Improved to_dict() - to_dict() is now slightly faster</li> </ul>"},{"location":"reference/release_notes/#v1100","title":"v1.10.0","text":"<ul> <li>\u2b06\ufe0f Update to zip - added longest and fillvalue to the zip method</li> <li>\ud83c\udf1f Interleave - new interleave method, for  interleaving two or more iterables together, in a round-robin fashion, regardless of their length</li> </ul>"},{"location":"reference/release_notes/#v190","title":"v1.9.0","text":"<ul> <li>\ud83d\udcdd Release Notes - starting to log release notes</li> <li>\u2699\ufe0f Type Support - added full type support (including generics)</li> </ul>"},{"location":"reference/release_notes/#v170-and-earlier","title":"v1.7.0 (and earlier)","text":"<ul> <li>\ud83d\udcdd Readme - added readme</li> <li>\u2699\ufe0f Testing - added unit tests with 100% coverage</li> <li>\u2699\ufe0f Packaging - added packaging</li> <li>\u2699\ufe0f Performance Tests - added performance tests</li> <li>\u2699\ufe0f Benchmarking - added benchmarking</li> <li>\ud83d\udcdd Documentation - added basic documentation using MkDocs</li> <li>\ud83d\udcdd API Reference - added API reference for entire functionality</li> <li>\ud83d\udcdd Examples - added examples</li> <li>\ud83c\udf1f Peeking - added peeking: a way to look at items in a query, without consuming it.</li> <li>\ud83c\udf1f Partitioning - added partitioning: a time and space efficient way to split a query into n sub-queries,  that a mutually exclusive and collectively exhaustive (MECE)</li> <li>\ud83c\udf1f Snapshots - added snapshots: a way to create a \"checkpoint\" for a Query, for efficient re-use.</li> </ul>"},{"location":"reference/release_notes/#legend","title":"Legend","text":"<p>\ud83c\udf1f New Feature - new feature</p> <p>\u2b06\ufe0f Upgrade - upgrade to an existing feature</p> <p>\ud83d\udcdd Documentation - documentation improvements</p> <p>\u2699\ufe0f Core - core improvements</p> <p>\u26a1\ufe0f Performance - performance improvements</p>"},{"location":"reference/code_api/api_index/","title":"API Index","text":""},{"location":"reference/code_api/api_index/#special-functionality","title":"Special Functionality","text":"<ul> <li> snap (aka cache, materialize)</li> <li> partition</li> <li> peek</li> </ul>"},{"location":"reference/code_api/api_index/#mapper-methods","title":"Mapper Methods","text":"<ul> <li> where (aka filter)</li> <li> select (aka map)</li> <li> exclude (aka where_not, remove_all) </li> <li> distinct</li> <li> group_by</li> <li> order_by</li> <li> reverse</li> <li> slice</li> <li> slide (aka sliding window)</li> <li> pairwise</li> <li> skip</li> <li> skip_last</li> <li> take</li> <li> top</li> <li> bottom</li> <li> zip</li> <li> interleave</li> <li> append</li> <li> prepend</li> <li> append_many</li> <li> prepend_many</li> <li> for_each</li> <li> shuffle</li> <li> flatten</li> <li> most_common</li> </ul>"},{"location":"reference/code_api/api_index/#materializers","title":"Materializers","text":"<ul> <li> contains</li> <li> equals</li> <li> to_list</li> <li> to_dict</li> <li> conversion (to_set, to_tuple, to_string)</li> </ul>"},{"location":"reference/code_api/api_index/#special-materializers","title":"Special Materializers","text":"<ul> <li> in / not in (aka membership)</li> <li> == / != (aka equality)</li> <li> arithmetic (+, -, *, , %)</li> </ul>"},{"location":"reference/code_api/api_index/#reducers","title":"Reducers","text":"<ul> <li> first</li> <li> last</li> <li> single</li> <li> sample</li> <li> count</li> <li> any</li> <li> all</li> <li> aggregate</li> </ul>"},{"location":"reference/code_api/api_index/#numeric-reducers","title":"Numeric Reducers","text":"<ul> <li> sum</li> <li> min</li> <li> max</li> <li> average</li> </ul>"},{"location":"reference/code_api/mapper_methods/","title":"Mapper Methods","text":""},{"location":"reference/code_api/mapper_methods/#fliq.query.Query.append","title":"append","text":"<pre><code>append(*single_items: T) -&gt; Query[T]\n</code></pre> <p>Yields the elements of the original query, followed by the input element(s). This supports multiple arguments, where each is considered as a single element.</p> <p>Infinite iterables are supported, behaving as expected.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q(range(5)).append(5).to_list()\n[0, 1, 2, 3, 4, 5]\n&gt;&gt;&gt; q(range(5)).append(5, 6, 7).to_list()\n[0, 1, 2, 3, 4, 5, 6, 7]\n</code></pre> <p>Parameters:</p> <ul> <li> <code>*single_items</code>             (<code>T</code>, default:                 <code>()</code> )         \u2013          <p>One or more elements to add to the end of the query.</p> </li> </ul>"},{"location":"reference/code_api/mapper_methods/#fliq.query.Query.append_many","title":"append_many","text":"<pre><code>append_many(items: Iterable[T]) -&gt; Query[T]\n</code></pre> <p>Yields the elements of the original query, followed by the elements given.</p> <p>Infinite iterables are supported, behaving as expected.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q(range(5)).append_many([5, 6, 7]).to_list()\n[0, 1, 2, 3, 4, 5, 6, 7]\n</code></pre> <p>Parameters:</p> <ul> <li> <code>items</code>             (<code>Iterable[T]</code>)         \u2013          <p>An iterable to concatenate to the end of the query.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013          <p>In case the elements are not iterable. Error will be raised when query is collected.</p> </li> </ul>"},{"location":"reference/code_api/mapper_methods/#fliq.query.Query.bottom","title":"bottom","text":"<pre><code>bottom(n: int = 1, by: Optional[NumericSelector[T]] = None) -&gt; Query[T]\n</code></pre> <p>Yields the bottom n elements of the query, according to the selector (if provided).</p> <p>This is done in O(N log n) time, and O(n) space. Where n is the number of elements to take, and N is the number of elements in the query.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q(range(10)).bottom(n=3).to_list()\n[0, 1, 2]\n</code></pre> <p>Parameters:</p> <ul> <li> <code>n</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Optional. The number of elements to take. Defaults to 1.</p> </li> <li> <code>by</code>             (<code>Optional[NumericSelector[T]]</code>, default:                 <code>None</code> )         \u2013          <p>Optional. The selector function to apply to each element. Defaults to the identity. If by is None, the default ordering is used, which requires elements to be able to be multiplied by integers.</p> </li> </ul>"},{"location":"reference/code_api/mapper_methods/#fliq.query.Query.distinct","title":"distinct","text":"<pre><code>distinct() -&gt; Query[T]\n</code></pre> <p>Yields distinct elements while preserving order. Distinct supports infinite iterables. Note that elements must be hashable.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q([0, 1, 0, 2, 2]).distinct().to_list()\n[0, 1, 2]\n</code></pre> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013          <p>In case one or more items in the query are not hashable.</p> </li> </ul>"},{"location":"reference/code_api/mapper_methods/#fliq.query.Query.exclude","title":"exclude","text":"<pre><code>exclude(predicate: Predicate[T]) -&gt; Query[T]\n</code></pre> <p>Yields elements that do not satisfy the predicate.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q(range(5)).exclude(lambda x: x &gt; 3).to_list()\n[0, 1, 2, 3]\n</code></pre> <p>Parameters:</p> <ul> <li> <code>predicate</code>             (<code>Predicate[T]</code>)         \u2013          <p>The predicate to filter the query by.</p> </li> </ul>"},{"location":"reference/code_api/mapper_methods/#fliq.query.Query.flatten","title":"flatten","text":"<pre><code>flatten(max_depth: Optional[int] = None, ignore_types: Optional[Tuple[Type[Any], ...]] = (str, bytes)) -&gt; Query[T]\n</code></pre> <p>Yields a flattened iterable to a specified depth.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q([[[1], 2], [3, 4]]).flatten().to_list()\n[1, 2, 3, 4]\n&gt;&gt;&gt; q([[[1], 2], [3, 4]]).flatten(max_depth=1).to_list()\n[[1], 2, 3, 4]\n&gt;&gt;&gt; q([['hello', 'world'], ['I', 'am', 'Fliq']]).flatten().to_list()\n['hello', 'world', 'I', 'am', 'Fliq']\n&gt;&gt;&gt; q([['hello', 'world'], ['I', 'am', 'Fliq']]).flatten(ignore_types=None).to_list()\n['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd', 'I', 'a', 'm', 'F', 'l', 'i', 'q']\n</code></pre> <p>Parameters:</p> <ul> <li> <code>max_depth</code>             (<code>Optional[int]</code>, default:                 <code>None</code> )         \u2013          <p>Optional. Non-negative. The maximum depth to flatten to. Defaults to none (no limit, completely flat). If max_depth is 0, the query is left unchanged.</p> </li> <li> <code>ignore_types</code>             (<code>Optional[Tuple[Type[Any], ...]]</code>, default:                 <code>(str, bytes)</code> )         \u2013          <p>Optional. A tuple of types to ignore flattening for. Defaults to (str, bytes).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>In case max_depth is non-positive.</p> </li> </ul>"},{"location":"reference/code_api/mapper_methods/#fliq.query.Query.group_by","title":"group_by","text":"<pre><code>group_by(key: Union[str, Selector[T, U]]) -&gt; Query[List[T]]\n</code></pre> <p>Yields an iterable of groups (as lists), where each group has identical key. If you require the group key, consider using <code>to_dict()</code> instead.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q([1, 2, 3]).group_by(lambda x: x % 2 == 0).to_list()\n[[1, 3], [2]]\n</code></pre> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>Union[str, Selector[T, U]]</code>)         \u2013          <p>A function that takes an element and returns its grouping key, or a string representing the name of an attribute to group by.</p> </li> </ul>"},{"location":"reference/code_api/mapper_methods/#fliq.query.Query.interleave","title":"interleave","text":"<pre><code>interleave(*iterables: Iterable[U]) -&gt; Query[Union[T, U]]\n</code></pre> <p>Combines the elements of the query with the elements of the provided iterables into a single Query. The elements are interleaved in the order they appear in their respective sources (similar to zip). The process continues until all sources are exhausted. No padding is done in case the iterables are of different lengths.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q([1, 2, 3]).interleave([4], [5, 6]).to_list()\n[1, 4, 5, 2, 6, 3]\n</code></pre> <p>Parameters:</p> <ul> <li> <code>*iterables</code>             (<code>Iterable[U]</code>, default:                 <code>()</code> )         \u2013          <p>One or more iterables to unify with the query.</p> </li> </ul>"},{"location":"reference/code_api/mapper_methods/#fliq.query.Query.most_common","title":"most_common","text":"<pre><code>most_common(n: int = 1) -&gt; Query[T]\n</code></pre> <p>Yields the most common n elements, in descending order of frequency. By definition, does not support inifinte iterables.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q([1, 2, 3, 1, 2, 1]).most_common(n=1).single()\n1\n&gt;&gt;&gt; q([1, 2, 3, 1, 2, 1]).most_common(n=2).to_list()\n[1, 2]\n</code></pre> <p>Parameters:</p> <ul> <li> <code>n</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Optional. The number of elements to return. Defaults to 1.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotEnoughElementsException</code>           \u2013          <p>In case the query does not have n items.</p> </li> </ul>"},{"location":"reference/code_api/mapper_methods/#fliq.query.Query.order","title":"order","text":"<pre><code>order(by: Optional[Selector[T, U]] = None, ascending: bool = True) -&gt; Query[T]\n</code></pre> <p>Yields elements in sorted order.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q([4, 3, 2, 1, 0]).order().to_list()\n[0, 1, 2, 3, 4]\n</code></pre> <p>Parameters:</p> <ul> <li> <code>by</code>             (<code>Optional[Selector[T, U]]</code>, default:                 <code>None</code> )         \u2013          <p>a selector function to extract the key from an item, defaults to None. If None, the default ordering is used. If exists, assumes the key is comparable.</p> </li> <li> <code>ascending</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>whether to sort in ascending or descending order, defaults to True.</p> </li> </ul>"},{"location":"reference/code_api/mapper_methods/#fliq.query.Query.pairwise","title":"pairwise","text":"<pre><code>pairwise(pad: Optional[T] = None) -&gt; Query[Tuple[T, T]]\n</code></pre> <p>Yields tuples of consecutive elements in the query. Practically this is a sliding window of size 2, with overlap 0.</p> <p>Parameters:</p> <ul> <li> <code>pad</code>             (<code>Optional[T]</code>, default:                 <code>None</code> )         \u2013          <p>The value to use for padding the last window in case the iterable size is odd.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q([1, 2, 3, 4]).pairwise().to_list()\n[(1, 2), (3, 4)]\n&gt;&gt;&gt; q([1, 2, 3, 4, 5]).pairwise().to_list()\n[(1, 2), (3, 4), (5, None)]\n</code></pre>"},{"location":"reference/code_api/mapper_methods/#fliq.query.Query.prepend","title":"prepend","text":"<pre><code>prepend(*single_items: T) -&gt; Query[T]\n</code></pre> <p>Yields the element(s) given, followed by the elements of the original query. This supports multiple arguments, where each is considered as a single element.</p> <p>Infinite iterables are supported, behaving as expected.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q(range(5)).prepend(5).to_list()\n[5, 0, 1, 2, 3, 4]\n&gt;&gt;&gt; q(range(5)).prepend(5, 6, 7).to_list()\n[5, 6, 7, 0, 1, 2, 3, 4]\n</code></pre> <p>Parameters:</p> <ul> <li> <code>*single_items</code>             (<code>T</code>, default:                 <code>()</code> )         \u2013          <p>One or more elements to add to the start of the query.</p> </li> </ul>"},{"location":"reference/code_api/mapper_methods/#fliq.query.Query.prepend_many","title":"prepend_many","text":"<pre><code>prepend_many(items: Iterable[T]) -&gt; Query[T]\n</code></pre> <p>Yields the elements given, followed by the elements of the original query.</p> <p>Infinite iterables are supported, behaving as expected.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q(range(5)).prepend_many([5, 6, 7]).to_list()\n[5, 6, 7, 0, 1, 2, 3, 4]\n</code></pre> <p>Parameters:</p> <ul> <li> <code>items</code>             (<code>Iterable[T]</code>)         \u2013          <p>The elements to add to the start of the query.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013          <p>In case the items are not iterable. Error will be raised when the query is collected.</p> </li> </ul>"},{"location":"reference/code_api/mapper_methods/#fliq.query.Query.reverse","title":"reverse","text":"<pre><code>reverse() -&gt; Query[T]\n</code></pre> <p>Yields elements in reverse order. Notes:  - in case of an irreversible query, TypeError is raised (e.g., set).  - in case of an iterator, it is first converted to a list, then reversed,  this has a performance and memory impact, and assumes a finite iterator.</p> <p>Examples:      &gt;&gt;&gt; from fliq import q     &gt;&gt;&gt; q([0, 1, 2, 3, 4]).reverse().to_list()     [4, 3, 2, 1, 0]</p> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013          <p>In case the iterable is irreversible.</p> </li> </ul>"},{"location":"reference/code_api/mapper_methods/#fliq.query.Query.select","title":"select","text":"<pre><code>select(selector: Selector[T, U]) -&gt; Query[U]\n</code></pre> <p>Yields the result of applying the selector function to each element (aka map).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q(range(5)).select(lambda x: x * 2).to_list()\n[0, 2, 4, 6, 8]\n</code></pre> <p>Parameters:</p> <ul> <li> <code>selector</code>             (<code>Selector[T, U]</code>)         \u2013          <p>The selector function to apply to each element.</p> </li> </ul>"},{"location":"reference/code_api/mapper_methods/#fliq.query.Query.shuffle","title":"shuffle","text":"<pre><code>shuffle(buffer_size: int = 10, seed: Optional[Hashable] = None, fair: bool = False) -&gt; Query[T]\n</code></pre> <p>Yields elements in a random order. Supports infinite iterables.</p> <p>Parameters:</p> <ul> <li> <code>buffer_size</code>             (<code>int</code>, default:                 <code>10</code> )         \u2013          <p>The size of the shuffle buffer for an unfair shuffle. Defaults to 10. Increasing the size of the buffer will require more memory. However, it will also result in a shuffle that is more evenly distributed (fair).</p> </li> <li> <code>seed</code>             (<code>Optional[Hashable]</code>, default:                 <code>None</code> )         \u2013          <p>Optional. The seed to use for the random shuffle. Defaults to None.</p> </li> <li> <code>fair</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to use a fair shuffle. Defaults to False. If True, each permutation of the elements will be equally likely.     This option does not support infinite iterables     (specifically, requires a sizeable iterable). This requires materialization     of the iterable, which is more memory intensive.     Use this for scenarios where fairness is important,     like rolling a die or shuffling a deck of cards. If False, each permutation of elements will NOT be equally likely.     However, this is more memory efficient, and supports infinite iterables.     Use this for scenarios where fairness is not top priority,     like shuffling a list of songs in a playlist.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q(range(10)).shuffle(seed=42, buffer_size=5).to_list()\n[1, 5, 6, 3, 0, 8, 7, 2, 4, 9]\n&gt;&gt;&gt; q(range(10)).shuffle(seed=42, fair=True).to_list()\n[7, 3, 2, 8, 5, 6, 9, 4, 0, 1]\n</code></pre> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013          <p>In case a fair shuffle is requested for a non-sizeable iterable.</p> </li> </ul>"},{"location":"reference/code_api/mapper_methods/#fliq.query.Query.skip","title":"skip","text":"<pre><code>skip(n: int = 1) -&gt; Query[T]\n</code></pre> <p>Yields the elements after skipping the first n (as returned from the iterator).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q(range(10)).skip(n=5).to_list()\n[5, 6, 7, 8, 9]\n</code></pre> <p>Parameters:</p> <ul> <li> <code>n</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Optional. The number of items to take. Defaults to 1.</p> </li> </ul>"},{"location":"reference/code_api/mapper_methods/#fliq.query.Query.slice","title":"slice","text":"<pre><code>slice(start: int = 0, stop: Optional[int] = None, step: int = 1) -&gt; Query[T]\n</code></pre> <p>Yields a slice of the query</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q(range(10)).slice(start=1, stop=6, step=2).to_list()\n[1, 3, 5]\n</code></pre> <p>Parameters:</p> <ul> <li> <code>start</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>Optional. The start index of the slice. Defaults to 0.</p> </li> <li> <code>stop</code>             (<code>Optional[int]</code>, default:                 <code>None</code> )         \u2013          <p>Optional. The stop index of the slice. Defaults to None.</p> </li> <li> <code>step</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Optional. The step of the slice. Defaults to 1.</p> </li> </ul>"},{"location":"reference/code_api/mapper_methods/#fliq.query.Query.slide","title":"slide","text":"<pre><code>slide(window: int, overlap: int, pad: Optional[T] = None) -&gt; Query[Tuple[T, ...]]\n</code></pre> <p>Yields a sliding window over the iterable. In practice, these are tuples of size 'window'  containing the current element and the next 'size-1' elements  in the iterable. The tuples overlap by 'overlap' elements.</p> <p>Parameters:</p> <ul> <li> <code>window</code>             (<code>int</code>)         \u2013          <p>The size of the tuples to be returned.</p> </li> <li> <code>overlap</code>             (<code>int</code>)         \u2013          <p>The number of elements that should overlap between consecutive tuples.</p> </li> <li> <code>pad</code>             (<code>Optional[T]</code>, default:                 <code>None</code> )         \u2013          <p>The value to use for padding the last window when the iterable is exhausted.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q([1, 2, 3, 4]).slide(window=3, overlap=2).to_list()\n[(1, 2, 3), (2, 3, 4)]\n&gt;&gt;&gt; q([1, 2, 3, 4]).slide(window=3, overlap=1).to_list()\n[(1, 2, 3), (3, 4, None)]\n&gt;&gt;&gt; q([1, 2, 3, 4]).slide(window=3, overlap=1, pad=-1).to_list()\n[(1, 2, 3), (3, 4, -1)]\n</code></pre>"},{"location":"reference/code_api/mapper_methods/#fliq.query.Query.take","title":"take","text":"<pre><code>take(n: int = 1, predicate: Optional[Predicate[T]] = None) -&gt; Query[T]\n</code></pre> <p>Yields up to n items that satisfy the predicate (if provided). In case the query is ordered, the first n elements are returned.</p> <p>Parameters:</p> <ul> <li> <code>n</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Optional. The number of elements to take. Defaults to 1.</p> </li> <li> <code>predicate</code>             (<code>Optional[Predicate[T]]</code>, default:                 <code>None</code> )         \u2013          <p>Optional. The predicate to filter the query by.</p> </li> </ul>"},{"location":"reference/code_api/mapper_methods/#fliq.query.Query.top","title":"top","text":"<pre><code>top(n: int = 1, by: Optional[NumericSelector[T]] = None) -&gt; Query[T]\n</code></pre> <p>Yields the top n elements of the query, according to the selector (if provided).</p> <p>This is done in O(N log n) time, and O(n) space. Where n is the number of elements to take, and N is the number of elements in the query.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q(range(10)).top(n=3).to_list()\n[9, 8, 7]\n&gt;&gt;&gt; q(range(10)).top(n=3, by=lambda x: x*-1).to_list()\n[0, 1, 2]\n</code></pre> <p>Parameters:</p> <ul> <li> <code>n</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Optional. The number of elements to take. Defaults to 1.</p> </li> <li> <code>by</code>             (<code>Optional[NumericSelector[T]]</code>, default:                 <code>None</code> )         \u2013          <p>Optional. The selector function to apply to each element. Defaults to the identity.</p> </li> </ul>"},{"location":"reference/code_api/mapper_methods/#fliq.query.Query.where","title":"where","text":"<pre><code>where(predicate: Optional[Predicate[T]] = None) -&gt; Query[T]\n</code></pre> <p>Yields elements that satisfy the predicate (aka filter).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q(range(10)).where(lambda x: x % 2 == 0).to_list()\n[0, 2, 4, 6, 8]\n</code></pre> <p>Parameters:</p> <ul> <li> <code>predicate</code>             (<code>Optional[Predicate[T]]</code>, default:                 <code>None</code> )         \u2013          <p>Optional. The predicate to filter the query by. If None is given, no filtering takes place.</p> </li> </ul>"},{"location":"reference/code_api/mapper_methods/#fliq.query.Query.zip","title":"zip","text":"<pre><code>zip(*iterables: Iterable[U], longest: bool = False, fill: Optional[Tuple[T, U]] = None) -&gt; Query[Tuple[T, U]]\n</code></pre> <p>Yields tuples of the elements of the query with the input iterables. The zipping stops as soon as the smallest of the iterables and the query is exhausted, unless longest is set to True, in which case the zipping stops when the longest iterable is     exhausted. If strict mode is enabled, all iterables must have the same length.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q(range(5)).zip([5, 6, 7]).to_list()\n[(0, 5), (1, 6), (2, 7)]\n&gt;&gt;&gt; q(range(5)).zip([5, 6, 7], longest=True).to_list()\n[(0, 5), (1, 6), (2, 7), (3, None), (4, None)]\n&gt;&gt;&gt; q(range(5)).zip([5, 6, 7], [8, 9, 10]).to_list()\n[(0, 5, 8), (1, 6, 9), (2, 7, 10)]\n&gt;&gt;&gt; q(range(5)).zip([5, 6, 7], [8, 9, 10], longest=True, fill=-1).to_list()\n[(0, 5, 8), (1, 6, 9), (2, 7, 10), (3, -1, -1), (4, -1, -1)]\n</code></pre> <p>Parameters:</p> <ul> <li> <code>*iterables</code>             (<code>Iterable[U]</code>, default:                 <code>()</code> )         \u2013          <p>One or more iterables to zip with the query.</p> </li> <li> <code>longest</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If True, stop zipping when the longest iterable is exhausted. If False (default), stop when the shortest iterable is exhausted.</p> </li> <li> <code>fill</code>             (<code>Optional[Tuple[T, U]]</code>, default:                 <code>None</code> )         \u2013          <p>The value to use for padding when the longest iterable is exhausted. relevant only when <code>longest</code> is True.</p> </li> </ul>"},{"location":"reference/code_api/materializer_methods/","title":"Materializer Methods","text":""},{"location":"reference/code_api/materializer_methods/#fliq.query.Query.aggregate","title":"aggregate","text":"<pre><code>aggregate(by: Callable[[T, T], U], initial: Optional[U] = None) -&gt; T\n</code></pre> <p>Applies an accumulator function over the query.</p> <p>For an optimized summation of numeric values, use <code>sum</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq.tests.fliq_test_utils import Point\n&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q([Point(0, 0), Point(1, 1), Point(2, 2)]).aggregate(by=lambda a, b: a + b)\nPoint(x=3, y=3)\n&gt;&gt;&gt; q([Point(1, 1), Point(2, 2)]).aggregate(by=lambda a, b: a + b, initial=Point(0, 0))\nPoint(x=3, y=3)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>by</code>             (<code>Callable[[T, T], U]</code>)         \u2013          <p>The accumulator function to apply to each two elements.</p> </li> <li> <code>initial</code>             (<code>Optional[U]</code>, default:                 <code>None</code> )         \u2013          <p>Optional. The initial value of the accumulator. Defaults to None. If provided, it will also serve as the default value for an empty query. If not provided, the first element of the query will be used as the initial value.</p> </li> </ul>"},{"location":"reference/code_api/materializer_methods/#fliq.query.Query.all","title":"all","text":"<pre><code>all(predicate: Optional[Predicate[T]] = None) -&gt; bool\n</code></pre> <p>Returns whether all elements in the query evaluate to true. If a predicate is provided, only elements that satisfy the predicate are considered.</p> <p>For custom types, consider providing a predicate or   implementing <code>__bool__</code> or <code>__len__</code> to support this method.  see https://docs.python.org/3/reference/datamodel.html#object.bool .</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q([True, True, True]).all()\nTrue\n&gt;&gt;&gt; q([True, False, True]).all()\nFalse\n</code></pre> <p>Parameters:</p> <ul> <li> <code>predicate</code>             (<code>Optional[Predicate[T]]</code>, default:                 <code>None</code> )         \u2013          <p>Optional. The predicate to filter the query by.</p> </li> </ul>"},{"location":"reference/code_api/materializer_methods/#fliq.query.Query.any","title":"any","text":"<pre><code>any(predicate: Optional[Predicate[T]] = None) -&gt; bool\n</code></pre> <p>Returns whether any element in the query evaluates to true. If a predicate is provided, only elements that satisfy the predicate are considered.</p> <p>For custom types, consider providing a predicate or   implementing <code>__bool__</code> or <code>__len__</code> to support this method.  see https://docs.python.org/3/reference/datamodel.html#object.bool .</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q([True, False, False]).any()\nTrue\n&gt;&gt;&gt; q([False, False, False]).any()\nFalse\n</code></pre> <p>Parameters:</p> <ul> <li> <code>predicate</code>             (<code>Optional[Predicate[T]]</code>, default:                 <code>None</code> )         \u2013          <p>Optional. The predicate to filter the iterable by.</p> </li> </ul>"},{"location":"reference/code_api/materializer_methods/#fliq.query.Query.contains","title":"contains","text":"<pre><code>contains(item: Any) -&gt; bool\n</code></pre> <p>Returns whether the query contains the given item (by equality, not identity). Query also supports the <code>in</code> and <code>not in</code> syntax, which are identical in functionality.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q([1, 2, 3]).contains(2)\nTrue\n&gt;&gt;&gt; q([1, 2, 3]).contains(4)\nFalse\n&gt;&gt;&gt; 2 in q([1, 2, 3])\nTrue\n</code></pre> <p>Parameters:</p> <ul> <li> <code>item</code>             (<code>Any</code>)         \u2013          <p>The item to test for.</p> </li> </ul>"},{"location":"reference/code_api/materializer_methods/#fliq.query.Query.count","title":"count","text":"<pre><code>count() -&gt; int\n</code></pre> <p>Returns the number of elements in the query.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q([1, 2, 3]).count()\n3\n</code></pre>"},{"location":"reference/code_api/materializer_methods/#fliq.query.Query.equals","title":"equals","text":"<pre><code>equals(other: Iterable[T], bag_compare: bool = False) -&gt; bool\n</code></pre> <p>Returns whether the query is equal to the given iterable. Query also supports the <code>==</code> and <code>!=</code> operators.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q([1, 2, 3]).equals([1, 2, 3])\nTrue\n&gt;&gt;&gt; q([1, 2, 3]).equals(q([1, 2]))\nFalse\n&gt;&gt;&gt; q([1, 2, 3]).equals([3, 2, 1], bag_compare=True)\nTrue\n</code></pre> <p>Parameters:</p> <ul> <li> <code>other</code>             (<code>Iterable[T]</code>)         \u2013          <p>The iterable to test for equality.</p> </li> <li> <code>bag_compare</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Optional. If True, compares the query and the other iterable as bags, ignoring order and duplicate items. Defaults to False.</p> </li> </ul>"},{"location":"reference/code_api/materializer_methods/#fliq.query.Query.first","title":"first","text":"<pre><code>first(predicate: Optional[Predicate[T]] = None, default: MissingOrOptional[T] = MISSING) -&gt; Optional[T]\n</code></pre> <p>Returns the first element in the query that satisfies the predicate (if provided),     or a default value if the query is empty.     If default is not provided, raises NoItemsFoundException in case the query is empty.</p> <p>Parameters:</p> <ul> <li> <code>predicate</code>             (<code>Optional[Predicate[T]]</code>, default:                 <code>None</code> )         \u2013          <p>Optional. The predicate to filter the query by.</p> </li> <li> <code>default</code>             (<code>MissingOrOptional[T]</code>, default:                 <code>MISSING</code> )         \u2013          <p>Optional. The default value to return in case the query is empty. Defaults to raise an exception if the query is empty.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NoItemsFoundException</code>           \u2013          <p>In case the query is empty.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q([1, 2, 3]).first()\n1\n&gt;&gt;&gt; q([]).first()\nTraceback (most recent call last):\n...\nfliq.exceptions.NoItemsFoundException\n&gt;&gt;&gt; q([]).first(default=-1)\n-1\n&gt;&gt;&gt; q([]).first(default=None) # returns None\n</code></pre>"},{"location":"reference/code_api/materializer_methods/#fliq.query.Query.max","title":"max","text":"<pre><code>max(by: Optional[Selector[T, U]] = None) -&gt; T\n</code></pre> <p>Returns the maximal element in the query. If a selector is provided, maximality is determined by the selected value.</p> <p>Custom types must provide a selector function or implement value comparisons (see https://docs.python.org/3/reference/expressions.html#value-comparisons).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q(range(5)).max()\n4\n&gt;&gt;&gt; q(range(5)).max(by=lambda x: x*-1)\n0\n</code></pre> <p>Parameters:</p> <ul> <li> <code>by</code>             (<code>Optional[Selector[T, U]]</code>, default:                 <code>None</code> )         \u2013          <p>Optional. The selector function to test for the maximal element. If None, the default ordering is used. If exists, assumes the key is comparable.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>In case the query is empty.</p> </li> </ul>"},{"location":"reference/code_api/materializer_methods/#fliq.query.Query.min","title":"min","text":"<pre><code>min(by: Optional[Selector[T, U]] = None) -&gt; T\n</code></pre> <p>Returns the minimal element in the query. If a selector is provided, minimality is determined by the selected value.</p> <p>Custom types must provide a selector function or implement value comparisons (see https://docs.python.org/3/reference/expressions.html#value-comparisons).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q(range(5)).min()\n0\n&gt;&gt;&gt; q(range(5)).min(by=lambda x: x*-1)\n4\n</code></pre> <p>Parameters:</p> <ul> <li> <code>by</code>             (<code>Optional[Selector[T, U]]</code>, default:                 <code>None</code> )         \u2013          <p>Optional. The selector function to test for the minimal element. If None, the default ordering is used. If exists, assumes the key is comparable.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>In case the query is empty.</p> </li> </ul>"},{"location":"reference/code_api/materializer_methods/#fliq.query.Query.sample","title":"sample","text":"<pre><code>sample(n: int = 1, seed: Optional[Hashable] = None, budget_factor: Optional[int] = 10, stop_factor: Optional[int] = 10) -&gt; Union[T, List[T]]\n</code></pre> <p>Returns a random sample of n elements from the query. If n is 1, returns a single item, otherwise returns a tuple (that can be unpacked).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q(range(10)).sample(n=2, seed=42)\n[0, 4]\n&gt;&gt;&gt; q(range(10)).sample(n=1, seed=42)\n1\n</code></pre> <p>Parameters:</p> <ul> <li> <code>n</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Optional. The number of elements to sample. Defaults to 1.</p> </li> <li> <code>seed</code>             (<code>Optional[Hashable]</code>, default:                 <code>None</code> )         \u2013          <p>Optional. The seed to use for the random sample. Defaults to None.</p> </li> <li> <code>budget_factor</code>             (<code>Optional[int]</code>, default:                 <code>10</code> )         \u2013          <p>Optional. Limits the number of attempts to sample n items, as a factor of n. Defaults to 10x n. None will disable budgeting, and may exhaust the iterable (depending on stop_factor).</p> </li> <li> <code>stop_factor</code>             (<code>Optional[int]</code>, default:                 <code>10</code> )         \u2013          <p>Optional. The probability to stop re-sampling once the sample is full, as a factor of n: 1 / ( stop_factor * n). Defaults to 1 / (10 * n). None will disable early stopping, and may exhaust the iterable (depending on budget_factor).</p> </li> </ul> Note <ul> <li>To safely support infinite iterables, make sure you use     budget_factor and/or stop_factor (they are set by default).</li> </ul> <p>Raises:</p> <ul> <li> <code>NotEnoughItemsFoundException</code>           \u2013          <p>In case the query is exhausted before n items are sampled.</p> </li> <li> <code>ValueError</code>           \u2013          <p>In case n is not positive.</p> </li> </ul>"},{"location":"reference/code_api/materializer_methods/#fliq.query.Query.single","title":"single","text":"<pre><code>single(predicate: Optional[Predicate[T]] = None, default: MissingOrOptional[T] = MISSING) -&gt; Optional[T]\n</code></pre> <p>Returns the single element in the query, or a default value if the query is empty.     Single expects the query to have at most one element (if default is provided), or     exactly one element (if default is not provided).</p> <p>Parameters:</p> <ul> <li> <code>predicate</code>             (<code>Optional[Predicate[T]]</code>, default:                 <code>None</code> )         \u2013          <p>Optional. The predicate to filter the query by.</p> </li> <li> <code>default</code>             (<code>MissingOrOptional[T]</code>, default:                 <code>MISSING</code> )         \u2013          <p>Optional. The default value to return in case the query is empty. Defaults to raise an exception if the query is empty.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q([1]).single()\n1\n&gt;&gt;&gt; q([]).single()\nTraceback (most recent call last):\n...\nfliq.exceptions.NoItemsFoundException\n&gt;&gt;&gt; q([1]).single(default=None)\n1\n&gt;&gt;&gt; q([]).single(default=None) # returns None\n</code></pre> <pre><code>&gt;&gt;&gt; q([1, 2, 3]).single(default=None)\nTraceback (most recent call last):\n...\nfliq.exceptions.MultipleItemsFoundException\n</code></pre> <p>Raises:</p> <ul> <li> <code>NoItemsFoundException</code>           \u2013          <p>In case the query is empty.</p> </li> <li> <code>MultipleItemsFoundException</code>           \u2013          <p>In case the query has more than one element.</p> </li> </ul>"},{"location":"reference/code_api/materializer_methods/#fliq.query.Query.sum","title":"sum","text":"<pre><code>sum(by: Optional[NumericSelector[T]] = None, accumulator: Union[int, float] = 0) -&gt; Union[int, float]\n</code></pre> <p>Returns the sum of the elements in the query. If a selector is provided, the sum of the selected elements is returned. If an accumulator is provided, it is used as the initial value for the summation.</p> <p>Custom types must provide a selector function or implement <code>__add__</code> and optionally <code>__radd__</code> (see https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types).</p> <p>Use this method for optimized summation of numeric values, for other types of aggregation,  use aggregate.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q(range(5)).sum()\n10\n&gt;&gt;&gt; q(range(5)).sum(by=lambda x: x*2)\n20\n</code></pre> <p>Parameters:</p> <ul> <li> <code>by</code>             (<code>Optional[NumericSelector[T]]</code>, default:                 <code>None</code> )         \u2013          <p>Optional. The selector function to apply to each element.</p> </li> <li> <code>accumulator</code>             (<code>Union[int, float]</code>, default:                 <code>0</code> )         \u2013          <p>Optional. The initial value of the sum. Defaults to 0.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Union[int, float]</code>         \u2013          <p>The sum of the elements in the iterable.</p> </li> </ul>"},{"location":"reference/code_api/materializer_methods/#fliq.query.Query.to_dict","title":"to_dict","text":"<pre><code>to_dict(key: Union[str, Selector[T, U]]) -&gt; Dict[U, List[T]]\n</code></pre> <p>Returns the elements of the query as a dictionary, grouped by the given key. If you don't require the group key, consider using <code>group_by()</code> instead.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q([1, 2, 3]).to_dict(key=lambda x: x % 2 == 0)\n{False: [1, 3], True: [2]}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>Union[str, Selector[T, U]]</code>)         \u2013          <p>The selector function to apply to each element, or a string representing the name of an attribute to group by.</p> </li> </ul>"},{"location":"reference/code_api/materializer_methods/#fliq.query.Query.to_list","title":"to_list","text":"<pre><code>to_list() -&gt; List[T]\n</code></pre> <p>Returns the elements of the query as a list.</p>"},{"location":"reference/code_api/partitioning/","title":"\u2702\ufe0f Query Partitioning","text":"<p>Query partitioning is a time and space efficient way to split a query into n sub-queries,  that a mutually exclusive and collectively exhaustive (MECE). The original iterable is only iterated once, and the sub-queries are lazily evaluated.</p> <p>Note</p> <p>Paritioning is done lazily. It does not incur any performance penalty. Thus, it can be freely used even where logic  may lead to some sub-queries eventually not being consumed.</p> <p>One common use case is to split a query into two sub-queries, depending on a condition. So, for example, instead of writing: <pre><code>numbers = [1, 2, 3, 4, 5]\neven = [x for x in numbers if x % 2 == 0]\nod = [x for x in numbers if x % 2 != 0]\n</code></pre> Using Fliq, you can write: <pre><code>from fliq import q\nnumbers = q([1, 2, 3, 4, 5])\neven, od = numbers.partition(lambda x: x % 2 == 0)\n</code></pre></p> <p>This is more:</p> <ul> <li>Time-efficient. The iterable is only iterated once.</li> <li>Space-efficient. Both sub-queries are lazily evaluated, so they do not materialize the iterable,  thus using less memory.</li> <li>Readable. Less repetitive, more declarative.</li> </ul>"},{"location":"reference/code_api/partitioning/#partition","title":"<code>partition()</code>","text":"<p>Yields n queries, each containing the elements that match the partition index selected. Supports infinite iterables, conditioned that there are finite sequences between elements of different partitions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; first, second, third = q(range(10)).partition(lambda x: x % 3, n=3)\n&gt;&gt;&gt; first.to_list(), second.to_list(), third.to_list()\n([0, 3, 6, 9], [1, 4, 7], [2, 5, 8])\n&gt;&gt;&gt; even, odd = q([1, 2, 3]).partition(lambda x: x % 2 == 0)\n&gt;&gt;&gt; even.to_list(), odd.to_list()\n([1, 3], [2])\n</code></pre> <p>Parameters:</p> <ul> <li> <code>by</code>             (<code>Union[IndexSelector[T], Predicate[T]]</code>)         \u2013          <p>IndexSelector that returns partition index for each element, in the range [0, n). Or, a Predicate to be used for a binary partition (when n=2). In case of a Selector, the first query will contain the elements in partition 0, the second query will contain the elements in partition 1, and so on. In case of a Predicate, the first query will contain the elements that don't satisfy  the predicate (for alignment between 0 and False as the first index).</p> </li> <li> <code>n</code>             (<code>int</code>, default:                 <code>2</code> )         \u2013          <p>Optional. The number of partitions to create. Defaults to 2. Must be positive. When n=2, <code>by</code> can also be a Predicate.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>In case the partition index is outside the range [0, n).</p> </li> <li> <code>TypeError</code>           \u2013          <p>In case the partition index is not an integer.</p> </li> </ul>"},{"location":"reference/code_api/peeking/","title":"\ud83e\udee3 Query Peeking","text":"<p>Queries are lazy and can only be used once (they are exhausted after being iterated). While this provides a significant performance boost, it can be inconvenient in some cases.</p> <p>Peeking is a way to look at items in a query, without consuming it.</p>"},{"location":"reference/code_api/peeking/#common-use-cases","title":"Common Use Cases","text":""},{"location":"reference/code_api/peeking/#debugging","title":"Debugging","text":"<p>When debugging a query, it is often useful to see what the next item is, without consuming the query, since consuming may change the course of the function. <pre><code>from fliq import q\nnumbers = q([1, 2, 3, 4, 5])\n# Breakpoint here: dev takes a look at the next item using `numbers.peek()`\neven = numbers.where(lambda x: x % 2 == 0)  # flow continues as usual\n</code></pre></p>"},{"location":"reference/code_api/peeking/#logging","title":"Logging","text":"<p>In some cases, developers may want to log a sample of the data. However, this may be needed at a point in time where the query does not need to be materialized. For such case, peeking is useful. <pre><code>from fliq import q\nimport logging\nnumbers = q([1, 2, 3, 4, 5])\nlogging.info(f\"Sample item: {numbers.peek()}\")  # logging a sample item\neven = numbers.where(lambda x: x % 2 == 0)  # flow continues as usual\n</code></pre></p>"},{"location":"reference/code_api/peeking/#peeking","title":"Peeking","text":"<p>Peeking is done using the <code>peek</code> method.</p> <p>What makes peeking very powerful, is that you can peek a query at any point in its lifetime. Yes, even during iteration! <pre><code>from fliq import q\nitems = q(range(5))\niterated = []\npeeked = None\nfor i, element in enumerate(items):\nif i == 1:\npeeked = items.peek()  # \ud83e\udee3 peeking during iteration!\niterated.append(element)\nassert iterated == [i for i in range(5)]\nassert peeked == 2\n</code></pre></p>"},{"location":"reference/code_api/peeking/#peek","title":"<code>peek()</code>","text":"<p>Return the first n elements of the query, without exhausting the query. If n is 1, returns the first element as a single item, otherwise returns a tuple (that can be unpacked). If n is greater than the number of elements in the query, <code>pad</code> will be returned for the remaining items (defaults to None). Use this to inspect the first n elements of the query, before consuming the query itself. Common use cases are logging and debugging.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; items = q(range(10))\n&gt;&gt;&gt; i0, i1 = items.peek(2)\n&gt;&gt;&gt; i0, i1\n(0, 1)\n&gt;&gt;&gt; items.to_list()\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n&gt;&gt;&gt; a, b = q([]).peek(n=2)\n&gt;&gt;&gt; a, b\n(None, None)\n</code></pre> Notes <p>Uses O(n) memory, as it materializes the first n elements. Supports infinite iterables.</p> <p>Parameters:</p> <ul> <li> <code>n</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Optional. The number of elements to peek. Defaults to 1.</p> </li> <li> <code>pad</code>             (<code>Optional[T]</code>, default:                 <code>None</code> )         \u2013          <p>Optional. The value to use for padding when the query is exhausted.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>In case n is not positive.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Union[Optional[T], Sequence[Optional[T]]]</code>         \u2013          <p>A tuple of the first n elements of the query. If the query has less than n elements, the other missing elements will be returned as None.</p> </li> </ul>"},{"location":"reference/code_api/representation/","title":"\ud83d\udcf8 Query Representation","text":"<p>One of the pain points of working with lazy iterator (e.g., generators) is that they are not \"inspectable\". That is, you can't see what's inside it, without consuming it.  This makes it hard to debug, and hard to understand what's going on, which eventually slows down development.</p> <p>Fliq solves this problem by providing a <code>repr</code> method for queries,  which returns a string representation of the query,  including peeking (see peeking) into the query without consuming it.</p>"},{"location":"reference/code_api/representation/#repr","title":"<code>repr()</code>","text":"<p>Returns a string representation of the query, while peeking at actual elements within the query. Query stays intact (i.e., no items are consumed). If representation is long, only the first 10 elements are shown, followed by an ellipsis. Elements are represented using their <code>repr</code> function. Inner iterable is represented as a list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; q(range(10))\nQuery([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; q(range(100))\nQuery([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...])\n&gt;&gt;&gt; q([])\nQuery([])\n&gt;&gt;&gt; repr(q(range(3)))\n'Query([0, 1, 2])'\n</code></pre> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A string representation of the query.</p> </li> </ul>"},{"location":"reference/code_api/snapshots/","title":"\ud83d\udcf8 Query Snapshots","text":"<p>Queries are lazy and can only be used once (they are exhausted after being iterated). While this provides a significant performance boost, it can be inconvenient in some cases.</p> <p>This is where snapshots come in.</p> <p>Snapshots provide a way to create a \"checkpoint\" for a Query. The snapshot is a Query object, which can be used multiple times, without being exhausted.</p> <p>Snapshots are Query objects, so they support the same behavior as regular queries. The only difference is that they can be re-used (at the point of the snapping).</p> <p>Snapshots are created using the <code>snap</code> method.</p>"},{"location":"reference/code_api/snapshots/#snap","title":"<code>snap()</code>","text":"<p>Yields the same elements, and creates a snapshot for the query. This snapshot allows for multiple iterations over the same \"snapped\" iterable. If multiple snapshots are created in a query lifetime, the last one is considered.</p> <p>Assumes a finite iterable.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from fliq import q\n&gt;&gt;&gt; evens = q(range(10)).where(lambda x: x % 2 == 0).snap()\n&gt;&gt;&gt; evens.where(lambda x: x &gt; 3).count()\n3\n&gt;&gt;&gt; evens.first()\n0\n&gt;&gt;&gt; evens.select(lambda x: x ** 2).to_list()\n[0, 4, 16, 36, 64]\n</code></pre>"}]}